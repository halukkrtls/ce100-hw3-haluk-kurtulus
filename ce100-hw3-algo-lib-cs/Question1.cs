using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace ce100_hw3_algo_lib_cs
{
    public class Question1
    {
        // This is a class representing a node in a binary tree used for Huffman coding.
        // The node has properties for a symbol and its frequency, as well as pointers to its left and right child nodes.
        // The class also has a method for traversing the tree and returning the Huffman code for a given symbol,
        // represented as a list of boolean values.
        public class Node
        {
            public char Symbol { get; set; }
            public int Frequency { get; set; }
            public Node Right { get; set; }
            public Node Left { get; set; }

            public List<bool> Traverse(char symbol, List<bool> data)
            {
                // Leaf
                if (Right == null && Left == null)
                {
                    if (symbol.Equals(this.Symbol))
                    {
                        return data;
                    }
                    else
                    {
                        return null;
                    }
                }
                else
                {
                    List<bool> left = null;
                    List<bool> right = null;

                    if (Left != null)
                    {
                        List<bool> leftPath = new List<bool>();
                        leftPath.AddRange(data);
                        leftPath.Add(false);

                        left = Left.Traverse(symbol, leftPath);
                    }

                    if (Right != null)
                    {
                        List<bool> rightPath = new List<bool>();
                        rightPath.AddRange(data);
                        rightPath.Add(true);
                        right = Right.Traverse(symbol, rightPath);
                    }

                    if (left != null)
                    {
                        return left;
                    }
                    else
                    {
                        return right;
                    }
                }
            }

        }


        // This is a class representing a Huffman tree used for text compression.
        // The tree is built from a given source string by first calculating the frequency of each symbol in the string,
        // then creating a leaf node for each symbol with its frequency as the node's weight.
        // The nodes are sorted by frequency and combined pairwise to create parent nodes with weights equal to the sum of their children's weights,
        // until only the root node remains.
        // The class has properties for the nodes in the tree and the root node, as well as a dictionary to store symbol frequencies.
        public class HuffmanTree
        {
            public List<Node> nodes = new List<Node>();
            public Node Root { get; set; }
            public Dictionary<char, int> Frequencies = new Dictionary<char, int>();

            public void Build(string source)
            {
                for (int i = 0; i < source.Length; i++)
                {
                    if (!Frequencies.ContainsKey(source[i]))
                    {
                        Frequencies.Add(source[i], 0);
                    }

                    Frequencies[source[i]]++;
                }

                foreach (KeyValuePair<char, int> symbol in Frequencies)
                {
                    nodes.Add(new Node() { Symbol = symbol.Key, Frequency = symbol.Value });
                }

                while (nodes.Count > 1)
                {
                    List<Node> orderedNodes = nodes.OrderBy(node => node.Frequency).ToList<Node>();

                    if (orderedNodes.Count >= 2)
                    {
                        // Take first two items
                        List<Node> taken = orderedNodes.Take(2).ToList<Node>();

                        // Create a parent node by combining the frequencies
                        Node parent = new Node()
                        {
                            Symbol = '*',
                            Frequency = taken[0].Frequency + taken[1].Frequency,
                            Left = taken[0],
                            Right = taken[1]
                        };

                        nodes.Remove(taken[0]);
                        nodes.Remove(taken[1]);
                        nodes.Add(parent);
                    }

                    this.Root = nodes.FirstOrDefault();

                }

            }

            // This method takes a source string and encodes it using the Huffman tree generated by the Build method.
            // Each symbol in the string is traversed through the tree to get its corresponding Huffman code, which is then added to a list of boolean values.
            // The list is then converted into a BitArray and returned as the encoded representation of the source string.
            public BitArray Encode(string source)
            {
                List<bool> encodedSource = new List<bool>();

                for (int i = 0; i < source.Length; i++)
                {
                    List<bool> encodedSymbol = this.Root.Traverse(source[i], new List<bool>());
                    encodedSource.AddRange(encodedSymbol);
                }

                BitArray bits = new BitArray(encodedSource.ToArray());

                return bits;
            }

            // This method takes a BitArray representing an encoded string and decodes it using the Huffman tree generated by the Build method.
            // The method reads each bit in the BitArray from left to right and traverses the tree accordingly.
            // If the bit is 1, the method traverses to the right child node, and if the bit is 0, it traverses to the left child node.
            // Once a leaf node is reached, the corresponding symbol is appended to a decoded string, and the tree traversal starts over from the root node.
            // This process continues until all bits in the BitArray have been read and the entire encoded string has been decoded.
            public string Decode(BitArray bits)
            {
                Node current = this.Root;
                string decoded = "";

                foreach (bool bit in bits)
                {
                    if (bit)
                    {
                        if (current.Right != null)
                        {
                            current = current.Right;
                        }
                    }
                    else
                    {
                        if (current.Left != null)
                        {
                            current = current.Left;
                        }
                    }

                    if (IsLeaf(current))
                    {
                        decoded += current.Symbol;
                        current = this.Root;
                    }
                }

                return decoded;
            }

            // This method takes a node in the Huffman tree and returns a boolean value indicating whether or not the node is a leaf node.
           // A leaf node is defined as a node that has no left or right child nodes.
           // Therefore, this method checks if the given node has both left and right child nodes, and returns false if it does,
           // otherwise it returns true indicating that the node is a leaf node.
            public bool IsLeaf(Node node)
            {
                return (node.Left == null && node.Right == null);
            }

            public void BuildFromFile(string path)
            {
                // Read file contents
                string text = File.ReadAllText(path);

                // Build Huffman tree
                Build(text);
            }

            // This method takes the path to an input file and an output file as arguments, reads the contents of the input file,
            // encodes the text using the Huffman coding algorithm implemented in the Encode method, and then writes the encoded data to the output file.
            // Specifically, it first reads the contents of the file at the sourcePath location into a string variable called "text".
            // Then, it encodes the text using the Encode method implemented earlier to get a BitArray representation of the encoded data.
            // After that, it creates a FileStream object with the output file path and writes the encoded data to the file using a BinaryWriter object.
            public void EncodeToFile(string sourcePath, string outputPath)
            {
                // Read file contents
                string text = File.ReadAllText(sourcePath);

                // Encode text
                BitArray encoded = Encode(text);

                // Write encoded data to file
                using (FileStream stream = new FileStream(outputPath, FileMode.Create))
                {
                    using (BinaryWriter writer = new BinaryWriter(stream))
                    {
                        byte[] bytes = new byte[(encoded.Length - 1) / 8 + 1];
                        encoded.CopyTo(bytes, 0);
                        writer.Write(bytes);
                    }
                }
            }

            public string DecodeFromFile(string path)
            {
                // Read encoded data from file
                byte[] bytes = File.ReadAllBytes(path);
                BitArray encoded = new BitArray(bytes);

                // Decode data
                string decoded = Decode(encoded);

                return decoded;
            }
        }
    }
}
